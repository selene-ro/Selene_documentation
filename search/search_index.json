{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"Ejemplos/comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"Ejemplos/comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"Ejemplos/comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"Ejemplos/comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"Ejemplos/comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"Ejemplos/comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"Ejemplos/comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"Ejemplos/comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"Ejemplos/comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"Ejemplos/comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"Ejemplos/comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Ejemplos/comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"Ejemplos/comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"Ejemplos/comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"Ejemplos/comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"Ejemplos/comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"Ejemplos/ejemplo/","title":"Ejemplo","text":""},{"location":"Ejemplos/ejemplo/#pulsera-para-deteccion-de-hipoglucemia-nocturna","title":"Pulsera para detecci\u00f3n de hipoglucemia nocturna","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"Ejemplos/ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"Ejemplos/ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"Ejemplos/ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Ejemplos/ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"Ejemplos/gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"Ejemplos/gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"Ejemplos/gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"Ejemplos/gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"Ejemplos/gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"Ejemplos/gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"Ejemplos/gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"Ejemplos/gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Examen_1/simondice/","title":"\ud83d\udd34\ud83d\udfe1\ud83d\udd35\ud83d\udfe2 Sim\u00f3n Dice (4 colores) \u2013 RP Pico 2","text":"<p>Selene Rom\u00e1n Celis - 22/09/2025 </p>"},{"location":"Examen_1/simondice/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Construir un juego Sim\u00f3n Dice de 4 colores en Raspberry Pi Pico 2.</p> <ul> <li> <p>La secuencia crece +1 por ronda, de 1 hasta 15.</p> </li> <li> <p>La persona jugadora debe repetir la secuencia con 4 botones dentro de un tiempo l\u00edmite por ronda.</p> </li> <li> <p>Tiempo l\u00edmite por ronda (fase de entrada): TL = longitud + 5 segundos (p. ej., Ronda 7 \u2192 12 s).</p> </li> <li> <p>Puntaje (0\u201315): mostrar la m\u00e1xima ronda alcanzada en un display de 7 segmentos en hex (0\u20139, A, b, C, d, E, F).</p> </li> <li> <p>Aleatoriedad obligatoria: la secuencia debe ser impredecible en cada ejecuci\u00f3n.</p> </li> </ul> <p>Reglas del juego (obligatorias)</p> <ol> <li> <p>Encendido/Reset: el 7 segmentos muestra \u201c0\u201d y queda en espera de Start (cualquier bot\u00f3n permite iniciar).</p> </li> <li> <p>Reproducci\u00f3n: mostrar la secuencia actual (LEDs uno por uno con separaci\u00f3n clara).</p> </li> <li> <p>Entrada: al terminar la reproducci\u00f3n, la persona debe repetir la secuencia completa dentro de TL.</p> </li> <li> <p>Fallo (Game Over): bot\u00f3n incorrecto, falta/extra de entradas o exceder TL.</p> </li> <li> <p>Progresi\u00f3n: si acierta, puntaje = n\u00famero de ronda, agrega 1 color aleatorio y avanza.</p> </li> <li> <p>Fin: al fallar o completar la Ronda 15. Mostrar puntaje final en 7 segmentos (hex).</p> </li> </ol>"},{"location":"Examen_1/simondice/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n#include \"pico/time.h\"\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\n#define LED_0 0\n#define LED_1 1\n#define LED_2 4\n#define LED_3 5\n\n#define B_0 15\n#define B_1 14\n#define B_2 13\n#define B_3 12\n\n#define SEG_A 18\n#define SEG_B 17\n#define SEG_C 9\n#define SEG_D 10\n#define SEG_E 11\n#define SEG_F 19\n#define SEG_G 20\n\n#define RONDAS 15          // N\u00famero de rondas\n#define LED_ON 350         // Tiempo de LED encendido\n#define LED_OFF 250        // Tiempo entre LEDs\n#define PAUSA 800          // Pausa entre rondas\n#define TIEMPO 5000        // Tiempo base (5 seg)\n\n// D\u00edgitos hex del display\nconst uint8_t display[16][7] = {\n    {1,1,1,1,1,1,0},{0,1,1,0,0,0,0},{1,1,0,1,1,0,1},{1,1,1,1,0,0,1},\n    {0,1,1,0,0,1,1},{1,0,1,1,0,1,1},{1,0,1,1,1,1,1},{1,1,1,0,0,0,0},\n    {1,1,1,1,1,1,1},{1,1,1,1,0,1,1},{1,1,1,0,1,1,1},{0,0,1,1,1,1,1},\n    {1,0,0,1,1,1,0},{0,1,1,1,1,0,1},{1,0,0,1,1,1,1},{1,0,0,0,1,1,1}\n};\n\nconst uint8_t pin_display[7] = { SEG_A, SEG_B, SEG_C, SEG_D, SEG_E, SEG_F, SEG_G };\nconst uint8_t led[4] = { LED_0, LED_1, LED_2, LED_3 };\nconst uint8_t btn[4] = { B_0, B_1, B_2, B_3 };\n\n// Flancos (1 = no presionado)\nint estado_anterior[4] = {1,1,1,1};\n\n// Mostrar en el display\nstatic void digito_display(uint8_t value) {\n    value &amp;= 0x0F; // 0-15\n    for (int i = 0; i &lt; 7; i++)\n        gpio_put(pin_display[i], display[value][i] ? 0 : 1); // 0 \n}\n\n// Apagar display\nstatic void display_off(void) {\n    for (int i = 0; i &lt; 7; i++) gpio_put(pin_display[i], 1);\n}\n\n// Apaga LEDs\nstatic inline void leds_off(void){\n    sio_hw-&gt;gpio_clr = (1u&lt;&lt;LED_0)|(1u&lt;&lt;LED_1)|(1u&lt;&lt;LED_2)|(1u&lt;&lt;LED_3);\n}\n\nstatic inline void led_o(int in, bool on){\n    if (on) sio_hw-&gt;gpio_set = (1u&lt;&lt;led[in]);\n    else    sio_hw-&gt;gpio_clr = (1u&lt;&lt;led[in]);\n}\n\nstatic void parpadeo(int in, int on){\n    leds_off();\n    led_o(in, true);\n    sleep_ms(on);\n    leds_off();\n}\n\nint boton_flanco(void) {\n    for (int i = 0; i &lt; 4; i++) {\n        int lectura = gpio_get(btn[i]); \n\n        if (lectura == 0 &amp;&amp; estado_anterior[i] == 1) {\n            sleep_ms(40);\n            if (gpio_get(btn[i]) == 0) {\n                estado_anterior[i] = 0;\n                return i;\n            } else {\n                estado_anterior[i] = 1;\n            }\n        } else {\n            estado_anterior[i] = lectura;\n        }\n    }\n    return -1;\n}\n\nint esperar_boton(int tiempo){\n    absolute_time_t inicio = get_absolute_time();\n\n    while(1){\n\n        int64_t tiempo_us = absolute_time_diff_us(inicio, get_absolute_time());\n        if(tiempo_us &gt;= (int64_t)tiempo*1000) return -1; // Timeout\n\n        int b = boton_flanco();\n        if (b != -1) {\n            return b;\n        }\n\n        sleep_ms(1);\n    }\n}\n\n// Genera semilla usando tiempo y bot\u00f3n presionado\nuint32_t semilla(int btn_i){\n    uint32_t t = (uint32_t)(time_us_64() &amp; 0xFFFFFFFF);\n    uint32_t seed = t ^ (0x9E3779B1u * (uint32_t)(btn_i + 1));\n    if (seed == 0) seed = 0xA5A5A5A5u;\n    return seed;\n}\n\nint main(void){\n    stdio_init_all();\n\n    // Inicializar display\n    for (int i = 0; i &lt; 7; i++){\n        gpio_init(pin_display[i]);\n        gpio_set_dir(pin_display[i], GPIO_OUT);\n        gpio_put(pin_display[i], 1); // apagar\n    }\n\n    // Inicializar LEDs\n    for(int i=0;i&lt;4;i++){\n        gpio_init(led[i]);\n        gpio_set_dir(led[i], GPIO_OUT);\n        gpio_put(led[i],0);\n    }\n    leds_off();\n\n    // Inicializar botones\n    for(int i=0;i&lt;4;i++){\n        gpio_init(btn[i]);\n        gpio_set_dir(btn[i], GPIO_IN);\n        gpio_pull_up(btn[i]);\n    }\n\n    for (int i = 0; i &lt; 4; i++) estado_anterior[i] = gpio_get(btn[i]);\n\n    uint8_t secuencia[RONDAS];\n\n    while(true){\n        digito_display(0); // Mostrar 0 esperando inicio\n        int iniciar = esperar_boton(TIEMPO);\n        if(iniciar == -1) continue;\n        srand(semilla(iniciar)); // Semilla aleatoria\n\n        bool game_over = false;\n        int valor = 0;\n\n        for(int ronda=1; ronda&lt;=RONDAS &amp;&amp; !game_over; ronda++){\n            valor = ronda - 1;\n            digito_display(valor); // Mostrar ronda actual\n\n            for(int i=0;i&lt;ronda;i++)\n                secuencia[i] = rand()%4;\n\n            for(int i=0;i&lt;ronda;i++){\n                parpadeo(secuencia[i], LED_ON);\n                sleep_ms(LED_OFF);\n            }\n\n            int ronda_timeout = TIEMPO + (ronda - 1) * 1000;\n\n            int idx = 0;\n            while(idx &lt; ronda){\n                int b = esperar_boton(ronda_timeout);\n                if(b == -1 || b != (int)secuencia[idx]){ // Timeout o error\n                    game_over = true;\n                    break;\n                } else {\n                    parpadeo(b, 80); \n                    idx++;\n                }\n            }\n\n            if(!game_over) sleep_ms(PAUSA);\n        }\n\n        // Game over\n        while(true){\n            digito_display(valor);\n            sleep_ms(400);\n            display_off();\n            sleep_ms(200);\n\n            for(int i=0;i&lt;4;i++){\n                if(gpio_get(btn[i]) == 0){\n                    leds_off();\n                    goto Reiniciar;\n                }\n            }\n        }\nReiniciar:\n        continue;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Examen_1/simondice/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Examen_1/simondice/#video","title":"Video","text":""},{"location":"Examen_2/servomotor/","title":"\u2699\ufe0f\ud83d\udd04 Control de Servomotores con comandos","text":"<p>Selene Rom\u00e1n Celis - 23/10/2025 </p>"},{"location":"Examen_2/servomotor/#hardware-minimo","title":"Hardware m\u00ednimo","text":"<ul> <li> <p>1 \u00d7 servomotor en un pin PWM (50 Hz).</p> </li> <li> <p>3 \u00d7 botones:</p> <ul> <li> <p>BTN_MODE: cambia el modo activo (c\u00edclico: Entrenamiento \u2192 Continuo \u2192 Step \u2192 \u2026).</p> </li> <li> <p>BTN_NEXT: avanza a la siguiente posici\u00f3n (s\u00f3lo en Step).</p> </li> <li> <p>BTN_PREV: retrocede a la posici\u00f3n anterior (s\u00f3lo en Step).</p> </li> </ul> </li> <li> <p>Pi pico 2</p> </li> </ul>"},{"location":"Examen_2/servomotor/#modos-de-operacion","title":"Modos de operaci\u00f3n","text":"<p>1)  Modo Entrenamiento Se recibe texto por USB-serial con los comandos siguientes (se aceptan min\u00fasculas/may\u00fasculas indistintamente y tambi\u00e9n sus alias en ingl\u00e9s):</p> <ol> <li> <p>Borrar (alias: clear, borrar)</p> <ul> <li> <p>Sintaxis: Borrar</p> </li> <li> <p>Efecto: elimina la lista completa de posiciones.</p> </li> <li> <p>Respuesta: OK.</p> </li> </ul> </li> <li> <p>Escribir (alias: write, escribir)</p> <ul> <li> <p>Sintaxis: Escribir, v1, v2, ..., vn</p> <ul> <li>vi son enteros en 0\u2013180.</li> </ul> </li> <li> <p>Efecto: sobrescribe la lista con los valores dados en ese orden.</p> </li> <li> <p>Respuesta: OK si todos son v\u00e1lidos y la lisa de posiciones; si alguno est\u00e1 fuera de rango o la lista queda vac\u00eda \u2192 Error argumento invalido.</p> </li> </ul> </li> <li> <p>Reemplazar (alias: replace, reemplazar)</p> <ul> <li> <p>Sintaxis: Reemplazar, i, v</p> <ul> <li> <p>\u00cdndice i en base 1 (1 = primera posici\u00f3n).</p> </li> <li> <p>v en 0\u2013180.</p> </li> </ul> </li> <li> <p>Efecto: reemplaza el elemento i por v.</p> </li> <li> <p>Respuesta: OK. Si i no existe \u2192 Error indice invalido. Si v fuera de rango \u2192 Error argumento invalido.</p> </li> </ul> </li> </ol> <p>2) Modo Continuo</p> <ul> <li> <p>Recorre todas las posiciones de la lista en orden, moviendo el servo e imprimiendo cada 1.5 s:</p> <ul> <li>Formato: posX: V (por ejemplo, pos1: 90), donde X es base 1.</li> </ul> </li> <li> <p>Si la lista est\u00e1 vac\u00eda: imprimir cada 1.5 s Error no hay pos y no mover el servo.</p> </li> <li> <p>Al cambiar a otro modo, el ciclo se detiene inmediatamente.</p> </li> </ul> <p>3) Modo Step</p> <ul> <li> <p>BTN_NEXT: avanza una posici\u00f3n (si ya est\u00e1 en la \u00faltima, se mantiene en esa \u00faltima).</p> </li> <li> <p>BTN_PREV: retrocede una posici\u00f3n (si ya est\u00e1 en la primera, se mantiene en la primera).</p> </li> <li> <p>En cada cambio de posici\u00f3n:</p> <ul> <li> <p>mover el servo a la posici\u00f3n seleccionada;</p> </li> <li> <p>imprimir posX: V.</p> </li> </ul> </li> <li> <p>Si la lista est\u00e1 vac\u00eda: al presionar BTN_NEXT o BTN_PREV, imprimir Error no hay pos y no mover el servo.</p> </li> </ul> <p>INFO IMPORTANTE</p> <p>El movimiento de un servo requiere alimentacion 5-6v y en el pin de signal, un pwm a 50 HZ con un pulso de 1-2ms que representa 0-180 grados</p>"},{"location":"Examen_2/servomotor/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n#define SERVO_PIN 0\n#define SERVO_MIN 1000\n#define SERVO_MAX 2000\n#define FREC 50\n\n#define B_MODE 1\n#define B_NEXT 3\n#define B_PREV 2\n\n#define MAX_POS 10\n\nstring mensaje = \"\";\nint posiciones[MAX_POS];\nint total_pos = 0;\nint modo = 0;\nint pos_actual = 0;\nuint32_t ultimo_continuo = 0;\n\n// Funci\u00f3n para mover el servo\nvoid mover_servo(int angulo) {\n    if (angulo &lt; 0) angulo = 0;\n    if (angulo &gt; 180) angulo = 180;\n\n    float pulso = SERVO_MIN + (angulo / 180.0f) * (SERVO_MAX - SERVO_MIN);\n    float periodo = 1000000.0f / FREC;\n    uint16_t duty = (uint16_t)((pulso / periodo) * 65535);\n    pwm_set_gpio_level(SERVO_PIN, duty);\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configurar PWM\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN);\n    pwm_set_wrap(slice, 65535);\n    pwm_set_clkdiv(slice, 125000000.0f / (FREC * 65536));\n    pwm_set_enabled(slice, true);\n\n    gpio_init(B_MODE); \n    gpio_set_dir(B_MODE, GPIO_IN); \n    gpio_pull_up(B_MODE);\n\n    gpio_init(B_NEXT); \n    gpio_set_dir(B_NEXT, GPIO_IN); \n    gpio_pull_up(B_NEXT);\n\n    gpio_init(B_PREV); \n    gpio_set_dir(B_PREV, GPIO_IN); \n    gpio_pull_up(B_PREV);\n\n    while (true) {\n        // Cambio de modo\n        if (!gpio_get(B_MODE)) {\n            modo = (modo + 1) % 3;\n            pos_actual = 0;\n            if (modo == 0) printf(\"Modo Entrenamiento\\n\");\n            else if (modo == 1) printf(\"Modo Continuo\\n\");\n            else printf(\"Modo Step\\n\");\n            sleep_ms(300);\n        }\n\n        // Modo Entrenamiento\n        if (modo == 0) {\n            int ch = getchar_timeout_us(10000);\n            if (ch != PICO_ERROR_TIMEOUT) {\n                char c = (char)ch;\n                if (c == '\\r' || c == '\\n') continue;\n                mensaje += c;\n\n                if (c == ';') {\n                    string comando = mensaje.substr(0, mensaje.length() - 1);\n                    string cmd_lower = comando;\n                    for (auto &amp;ch : cmd_lower) ch = tolower(ch);\n\n                    // Comando clear/borrar\n                    if (cmd_lower == \"clear\" || cmd_lower == \"borrar\") {\n                        total_pos = 0;\n                        printf(\"OK\\n\");\n                    }\n                    // Comando write/escribir\n                    else if (cmd_lower.substr(0,5) == \"write\" || cmd_lower.substr(0,7) == \"escribir\") {\n                        int inicio = comando.find(',') + 1;\n                        bool error = false;\n                        while (inicio &gt; 0 &amp;&amp; inicio &lt; comando.length() &amp;&amp; total_pos &lt; MAX_POS) {\n                            int fin = comando.find(',', inicio);\n                            if (fin == string::npos) fin = comando.length();\n                            string val_str = comando.substr(inicio, fin - inicio);\n                            int val = atoi(val_str.c_str());\n                            if (val_str.empty() || val &lt; 0 || val &gt; 180) { error = true; break; }\n                            posiciones[total_pos++] = val;\n                            inicio = fin + 1;\n                        }\n                        if (error || total_pos == 0) printf(\"Error argumento invalido\\n\");\n                        else {\n                            printf(\"OK. Posiciones: \");\n                            for (int i = 0; i &lt; total_pos; i++) printf(\"%d \", posiciones[i]);\n                            printf(\"\\n\");\n                        }\n                    }\n                    // Comando replace/reemplazar\n                    else if (cmd_lower.substr(0,7) == \"replace\" || cmd_lower.substr(0,9) == \"reemplazar\") {\n                        int pos1 = comando.find(',') + 1;\n                        int pos2 = comando.find(',', pos1);\n                        if (pos1 &gt; 0 &amp;&amp; pos2 != string::npos) {\n                            int idx = atoi(comando.substr(pos1, pos2 - pos1).c_str()) - 1;\n                            int val = atoi(comando.substr(pos2 + 1).c_str());\n                            if (idx &lt; 0 || idx &gt;= total_pos) printf(\"Error indice invalido\\n\");\n                            else if (val &lt; 0 || val &gt; 180) printf(\"Error argumento invalido\\n\");\n                            else {\n                                posiciones[idx] = val;\n                                printf(\"OK\\n\");\n                            }\n                        } else printf(\"Error argumento invalido\\n\");\n                    }\n                    else printf(\"C\u00f3digo no reconocido\\n\");\n\n                    mensaje = \"\";\n                }\n            }\n        }\n\n        // Modo Continuo\n        if (modo == 1) {\n            uint32_t now = to_ms_since_boot(get_absolute_time());\n            if (now - ultimo_continuo &gt;= 1500) {\n                if (total_pos == 0) printf(\"Error no hay pos\\n\");\n                else {\n                    mover_servo(posiciones[pos_actual]);\n                    printf(\"pos%d: %d\\n\", pos_actual + 1, posiciones[pos_actual]);\n                    pos_actual = (pos_actual + 1) % total_pos;\n                }\n                ultimo_continuo = now;\n            }\n        }\n\n        // Modo Step\n        if (modo == 2) {\n            if (!gpio_get(B_NEXT)) {\n                if (total_pos == 0) printf(\"Error no hay pos\\n\");\n                else if (pos_actual &lt; total_pos - 1) pos_actual++;\n                if (total_pos &gt; 0) {\n                    mover_servo(posiciones[pos_actual]);\n                    printf(\"pos%d: %d\\n\", pos_actual + 1, posiciones[pos_actual]);\n                }\n                sleep_ms(200);\n            }\n            if (!gpio_get(B_PREV)) {\n                if (total_pos == 0) printf(\"Error no hay pos\\n\");\n                else if (pos_actual &gt; 0) pos_actual--;\n                if (total_pos &gt; 0) {\n                    mover_servo(posiciones[pos_actual]);\n                    printf(\"pos%d: %d\\n\", pos_actual + 1, posiciones[pos_actual]);\n                }\n                sleep_ms(200);\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Examen_2/servomotor/#video","title":"Video","text":""},{"location":"Proyecto/proyecto_final/","title":"\ud83d\udc2d Capstone Micromouse","text":"<p>Selene Rom\u00e1n Celis - 08/12/2025 </p>"},{"location":"Proyecto/proyecto_final/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>El proyecto Micromouse consiste en dise\u00f1ar y programar un robot m\u00f3vil aut\u00f3nomo capaz de explorar un laberinto, construir un mapa y ejecutar una carrera r\u00e1pida (fast run) desde el inicio hasta el objetivo en el centro.</p>"},{"location":"Proyecto/proyecto_final/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/i2c.h\"\n#include \"tof.h\" \n\n#define XSHUT_L 22\n#define XSHUT_F 3\n#define XSHUT_R 7\n#define ADDR_L 0x30\n#define ADDR_F 0x31\n#define ADDR_R 0x32\n\n#define PWMA 10  \n#define AIN2 11\n#define AIN1 12\n#define BIN1 13\n#define BIN2 14\n#define PWMB 15  \n#define ENC_IZQ_C1 21 \n#define ENC_DER_C1 5\n#define LED_PIN 25 \n\n#define TICKS_GIRO  175     \n#define TICKS_CELDA 465     \n#define SETPOINT_L  86     \n#define SETPOINT_R  61      \n\n#define VEL_EXPLORACION 11500 \n#define VEL_SPEED_RUN   16000 \n#define VEL_GIRO        14000\n#define VEL_LENTO       9000  \n\n#define KP_PARED    25      \n#define KD_PARED    350     \n#define KP_ENC      30     \n#define CLAMP_PID   6000    \n\n#define UMBRAL_PARED_LAT 180 \n#define DIST_STOP        50  \n\n#define ANCHO 12\n#define ALTO  12\n\n#define NORTE 0\n#define ESTE  1\n#define SUR   2\n#define OESTE 3\n\n#define PARED_N 1\n#define PARED_E 2\n#define PARED_S 4\n#define PARED_W 8\n\ntypedef struct {\n    uint8_t paredes;    \n    uint8_t distancia;  \n    bool visitada;      \n} Celda;\n\nCelda mapa[ANCHO][ALTO];\nint robot_x = 0;        \nint robot_y = 0;\nint orientacion = NORTE; \n\ntypedef struct { int x; int y; } Punto;\nPunto cola[ANCHO * ALTO]; \n\nvolatile long ticks_izq = 0;\nvolatile long ticks_der = 0;\n\nvoid encoder_callback(uint gpio, uint32_t events) {\n    if (gpio == ENC_IZQ_C1) ticks_izq++;\n    else if (gpio == ENC_DER_C1) ticks_der++;\n}\n\nvoid init_sensor_individual(uint pin, uint8_t addr) {\n    gpio_put(pin, 1); sleep_ms(15);\n    tofInit(1, 0x29, 0); vl53l0x_setAddress(addr); sleep_ms(10);\n}\n\nvoid set_motors(int L, int R) {\n    if(L&gt;65535) L=65535; if(L&lt;0) L=0;\n    if(R&gt;65535) R=65535; if(R&lt;0) R=0;\n    gpio_put(AIN1, 1); gpio_put(AIN2, 0); pwm_set_gpio_level(PWMA, L);\n    gpio_put(BIN1, 1); gpio_put(BIN2, 0); pwm_set_gpio_level(PWMB, R);\n}\n\nvoid frenar_total() {\n    gpio_put(AIN1, 1); gpio_put(AIN2, 1);\n    gpio_put(BIN1, 1); gpio_put(BIN2, 1);\n    pwm_set_gpio_level(PWMA, 65535); pwm_set_gpio_level(PWMB, 65535);\n    sleep_ms(200); set_motors(0, 0); sleep_ms(50);\n}\n\nvoid mover_motores_dir(int velocidad, bool hacia_adelante) {\n    if (hacia_adelante) {\n        gpio_put(AIN1, 1); gpio_put(AIN2, 0);\n        gpio_put(BIN1, 1); gpio_put(BIN2, 0);\n    } else {\n        gpio_put(AIN1, 0); gpio_put(AIN2, 1);\n        gpio_put(BIN1, 0); gpio_put(BIN2, 1);\n    }\n    pwm_set_gpio_level(PWMA, velocidad);\n    pwm_set_gpio_level(PWMB, velocidad);\n}\n\nint leer(uint8_t addr) {\n    i2cAddress = addr; return tofReadDistance();\n}\n\nvoid setup_system() {\n    stdio_init_all();\n    gpio_init(LED_PIN); gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    gpio_init(AIN1); gpio_set_dir(AIN1, GPIO_OUT); gpio_init(AIN2); gpio_set_dir(AIN2, GPIO_OUT);\n    gpio_init(BIN1); gpio_set_dir(BIN1, GPIO_OUT); gpio_init(BIN2); gpio_set_dir(BIN2, GPIO_OUT);\n    gpio_set_function(PWMA, GPIO_FUNC_PWM); gpio_set_function(PWMB, GPIO_FUNC_PWM);\n    pwm_set_wrap(pwm_gpio_to_slice_num(PWMA), 65535); pwm_set_wrap(pwm_gpio_to_slice_num(PWMB), 65535);\n    pwm_set_enabled(pwm_gpio_to_slice_num(PWMA), true); pwm_set_enabled(pwm_gpio_to_slice_num(PWMB), true);\n\n    gpio_init(ENC_IZQ_C1); gpio_set_dir(ENC_IZQ_C1, GPIO_IN);\n    gpio_init(ENC_DER_C1); gpio_set_dir(ENC_DER_C1, GPIO_IN);\n    gpio_set_irq_enabled_with_callback(ENC_IZQ_C1, GPIO_IRQ_EDGE_RISE, true, &amp;encoder_callback);\n    gpio_set_irq_enabled(ENC_DER_C1, GPIO_IRQ_EDGE_RISE, true);\n\n    i2c_init(i2c1, 400000);\n    gpio_set_function(26, GPIO_FUNC_I2C); gpio_set_function(27, GPIO_FUNC_I2C);\n    gpio_pull_up(26); gpio_pull_up(27);\n\n    gpio_init(XSHUT_L); gpio_set_dir(XSHUT_L, GPIO_OUT); gpio_put(XSHUT_L, 0);\n    gpio_init(XSHUT_F); gpio_set_dir(XSHUT_F, GPIO_OUT); gpio_put(XSHUT_F, 0);\n    gpio_init(XSHUT_R); gpio_set_dir(XSHUT_R, GPIO_OUT); gpio_put(XSHUT_R, 0);\n    sleep_ms(100);\n\n    init_sensor_individual(XSHUT_L, ADDR_L);\n    init_sensor_individual(XSHUT_F, ADDR_F);\n    init_sensor_individual(XSHUT_R, ADDR_R);\n}\n\n\nvoid centrar_frente_a_pared() {\n    int d_F = leer(ADDR_F);\n\n    if (d_F &gt; 0 &amp;&amp; d_F &lt; 150) {\n\n        unsigned long t_inicio = to_ms_since_boot(get_absolute_time());\n\n        while (abs(d_F - DIST_STOP) &gt; 2) {\n\n            if (to_ms_since_boot(get_absolute_time()) - t_inicio &gt; 1000) break;\n\n            d_F = leer(ADDR_F);\n            if (d_F &lt;= 0 || d_F &gt; 160) break; \n\n            if (d_F &lt; DIST_STOP) mover_motores_dir(VEL_LENTO, false); \n            else mover_motores_dir(VEL_LENTO, true);  \n\n            sleep_ms(10);\n        }\n        frenar_total();\n\n        ticks_izq = 0; ticks_der = 0; \n    }\n}\n\nvoid avanzar_celda_pid(int velocidad_objetivo) {\n    ticks_izq = 0; ticks_der = 0;\n    int last_error = 0;\n\n    long ticks_limite = TICKS_CELDA;\n    if (velocidad_objetivo &gt; 13000) ticks_limite -= 30; \n\n    while ((ticks_izq + ticks_der) / 2 &lt; ticks_limite) {\n        int d_L = leer(ADDR_L); \n        int d_R = leer(ADDR_R); \n        int d_F = leer(ADDR_F);\n\n        int dist_frenado = (velocidad_objetivo &gt; 13000) ? 70 : 45;\n        if (d_F &lt; dist_frenado &amp;&amp; d_F &gt; 0) break;\n\n\n        int error = 0;\n        bool pared_izq = (d_L &lt; UMBRAL_PARED_LAT &amp;&amp; d_L &gt; 0);\n        bool pared_der = (d_R &lt; UMBRAL_PARED_LAT &amp;&amp; d_R &gt; 0);\n        bool usar_paredes = true;\n\n        if (pared_izq &amp;&amp; pared_der) {\n\n            error = (d_L - SETPOINT_L) - (d_R - SETPOINT_R);\n        } \n        else if (pared_izq) {\n\n            error = (d_L - SETPOINT_L) * 2;\n        } \n        else if (pared_der) {\n\n            error = (SETPOINT_R - d_R) * 2;\n        } \n        else {\n\n            usar_paredes = false;\n            error = (ticks_izq - ticks_der) * KP_ENC; \n        }\n\n        if (abs(error) &lt; 4) error = 0;\n\n        int P = error * KP_PARED;\n        int D = (error - last_error) * KD_PARED;\n        if (!usar_paredes) D = 0; \n\n        last_error = error;\n\n        int correction = P + D;\n        if (correction &gt; CLAMP_PID) correction = CLAMP_PID;\n        if (correction &lt; -CLAMP_PID) correction = -CLAMP_PID;\n\n        set_motors(velocidad_objetivo - correction, velocidad_objetivo + correction);\n    }\n\n    set_motors(0, 0); \n    sleep_ms(velocidad_objetivo &gt; 13000 ? 10 : 50); \n}\n\nvoid girar_estatico(bool derecha) {\n    ticks_izq = 0; ticks_der = 0;\n    while ((ticks_izq + ticks_der) / 2 &lt; TICKS_GIRO) {\n        if(derecha) {\n            gpio_put(AIN1, 1); gpio_put(AIN2, 0); pwm_set_gpio_level(PWMA, VEL_GIRO);\n            gpio_put(BIN1, 0); gpio_put(BIN2, 1); pwm_set_gpio_level(PWMB, VEL_GIRO);\n        } else {\n            gpio_put(AIN1, 0); gpio_put(AIN2, 1); pwm_set_gpio_level(PWMA, VEL_GIRO);\n            gpio_put(BIN1, 1); gpio_put(BIN2, 0); pwm_set_gpio_level(PWMB, VEL_GIRO);\n        }\n    }\n    frenar_total();\n}\n\nvoid init_mapa() {\n    for(int x=0; x&lt;ANCHO; x++) {\n        for(int y=0; y&lt;ALTO; y++) {\n            mapa[x][y].paredes = 0;\n            mapa[x][y].distancia = 255; \n            mapa[x][y].visitada = false;\n        }\n    }\n    for(int x=0; x&lt;ANCHO; x++) { mapa[x][0].paredes |= PARED_S; mapa[x][ALTO-1].paredes |= PARED_N; }\n    for(int y=0; y&lt;ALTO; y++) { mapa[0][y].paredes |= PARED_W; mapa[ANCHO-1][y].paredes |= PARED_E; }\n\n    mapa[0][0].visitada = true;\n}\n\nvoid actualizar_flood_fill(bool modo_estricto) {\n\n    for(int x=0; x&lt;ANCHO; x++) \n        for(int y=0; y&lt;ALTO; y++) \n            mapa[x][y].distancia = 255;\n\n\n    mapa[5][5].distancia = 0; cola[0] = (Punto){5,5};\n    mapa[5][6].distancia = 0; cola[1] = (Punto){5,6};\n    mapa[6][5].distancia = 0; cola[2] = (Punto){6,5};\n    mapa[6][6].distancia = 0; cola[3] = (Punto){6,6};\n\n    int head = 0; int tail = 4; \n\n    while(head &lt; tail) {\n        Punto actual = cola[head++];\n        uint8_t dist_vecino = mapa[actual.x][actual.y].distancia + 1;\n\n        if (actual.y &lt; ALTO-1 &amp;&amp; !(mapa[actual.x][actual.y].paredes &amp; PARED_N)) {\n            if (!modo_estricto || mapa[actual.x][actual.y+1].visitada) { \n                if (mapa[actual.x][actual.y+1].distancia == 255) {\n                    mapa[actual.x][actual.y+1].distancia = dist_vecino;\n                    cola[tail++] = (Punto){actual.x, actual.y+1};\n                }\n            }\n        }\n        if (actual.y &gt; 0 &amp;&amp; !(mapa[actual.x][actual.y].paredes &amp; PARED_S)) {\n            if (!modo_estricto || mapa[actual.x][actual.y-1].visitada) {\n                if (mapa[actual.x][actual.y-1].distancia == 255) {\n                    mapa[actual.x][actual.y-1].distancia = dist_vecino;\n                    cola[tail++] = (Punto){actual.x, actual.y-1};\n                }\n            }\n        }\n\n        if (actual.x &lt; ANCHO-1 &amp;&amp; !(mapa[actual.x][actual.y].paredes &amp; PARED_E)) {\n            if (!modo_estricto || mapa[actual.x+1][actual.y].visitada) {\n                if (mapa[actual.x+1][actual.y].distancia == 255) {\n                    mapa[actual.x+1][actual.y].distancia = dist_vecino;\n                    cola[tail++] = (Punto){actual.x+1, actual.y};\n                }\n            }\n        }\n\n        if (actual.x &gt; 0 &amp;&amp; !(mapa[actual.x][actual.y].paredes &amp; PARED_W)) {\n            if (!modo_estricto || mapa[actual.x-1][actual.y].visitada) {\n                if (mapa[actual.x-1][actual.y].distancia == 255) {\n                    mapa[actual.x-1][actual.y].distancia = dist_vecino;\n                    cola[tail++] = (Punto){actual.x-1, actual.y};\n                }\n            }\n        }\n    }\n}\n\nvoid actualizar_paredes(int dir, bool existe) {\n    if (dir == NORTE &amp;&amp; robot_y &lt; ALTO-1) {\n        if(existe) { mapa[robot_x][robot_y].paredes |= PARED_N; mapa[robot_x][robot_y+1].paredes |= PARED_S; }\n    }\n    else if (dir == SUR &amp;&amp; robot_y &gt; 0) {\n        if(existe) { mapa[robot_x][robot_y].paredes |= PARED_S; mapa[robot_x][robot_y-1].paredes |= PARED_N; }\n    }\n    else if (dir == ESTE &amp;&amp; robot_x &lt; ANCHO-1) {\n        if(existe) { mapa[robot_x][robot_y].paredes |= PARED_E; mapa[robot_x+1][robot_y].paredes |= PARED_W; }\n    }\n    else if (dir == OESTE &amp;&amp; robot_x &gt; 0) {\n        if(existe) { mapa[robot_x][robot_y].paredes |= PARED_W; mapa[robot_x-1][robot_y].paredes |= PARED_E; }\n    }\n}\n\nvoid escanear_paredes() {\n    int f = leer(ADDR_F);\n    int r = leer(ADDR_R);\n    int l = leer(ADDR_L);\n\n    bool hay_f = (f &lt; UMBRAL_PARED_LAT &amp;&amp; f &gt; 0);\n    bool hay_r = (r &lt; UMBRAL_PARED_LAT &amp;&amp; r &gt; 0);\n    bool hay_l = (l &lt; UMBRAL_PARED_LAT &amp;&amp; l &gt; 0);\n\n    if(hay_f) actualizar_paredes(orientacion, true);\n    if(hay_r) actualizar_paredes((orientacion + 1) % 4, true);\n    if(hay_l) actualizar_paredes((orientacion + 3) % 4, true);\n\n    mapa[robot_x][robot_y].visitada = true;\n}\n\nvoid ejecutar_speed_run() {\n    printf(\"\\n--- MODO SPEED RUN ACTIVADO ---\\n\");\n    printf(\"TIENES 10 SEG PARA PONERME EN (0,0) NORTE\\n\");\n\n    for(int i=0; i&lt;10; i++) {\n        gpio_put(LED_PIN, 1); sleep_ms(200);\n        gpio_put(LED_PIN, 0); sleep_ms(800);\n    }\n\n    for(int i=0; i&lt;5; i++) { gpio_put(LED_PIN, 1); sleep_ms(50); gpio_put(LED_PIN, 0); sleep_ms(50); }\n\n    robot_x = 0; robot_y = 0; orientacion = NORTE;\n\n    actualizar_flood_fill(true);\n\n    while(1) {\n\n        if (mapa[robot_x][robot_y].distancia == 0) {\n            frenar_total();\n            printf(\"SPEED RUN COMPLETADO!!\\n\");\n            while(1) { gpio_put(LED_PIN, 1); sleep_ms(100); gpio_put(LED_PIN, 0); sleep_ms(100); }\n        }\n\n        int min_dist = 255;\n        int mejor_dir = -1;\n\n\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_N) &amp;&amp; robot_y &lt; ALTO-1) \n            if (mapa[robot_x][robot_y+1].distancia &lt; min_dist) { min_dist = mapa[robot_x][robot_y+1].distancia; mejor_dir = NORTE; }\n\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_E) &amp;&amp; robot_x &lt; ANCHO-1) \n            if (mapa[robot_x+1][robot_y].distancia &lt; min_dist) { min_dist = mapa[robot_x+1][robot_y].distancia; mejor_dir = ESTE; }\n\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_S) &amp;&amp; robot_y &gt; 0) \n            if (mapa[robot_x][robot_y-1].distancia &lt; min_dist) { min_dist = mapa[robot_x][robot_y-1].distancia; mejor_dir = SUR; }\n\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_W) &amp;&amp; robot_x &gt; 0) \n            if (mapa[robot_x-1][robot_y].distancia &lt; min_dist) { min_dist = mapa[robot_x-1][robot_y].distancia; mejor_dir = OESTE; }\n\n        if (mejor_dir == -1) {\n            frenar_total();\n            printf(\"ERROR: RUTA BLOQUEADA EN SPEED RUN\\n\"); break;\n        }\n\n        centrar_frente_a_pared(); \n\n        int diferencia = (mejor_dir - orientacion + 4) % 4;\n        if (diferencia == 1) { girar_estatico(true); orientacion = (orientacion + 1) % 4; }\n        else if (diferencia == 3) { girar_estatico(false); orientacion = (orientacion + 3) % 4; }\n        else if (diferencia == 2) { girar_estatico(true); girar_estatico(true); orientacion = (orientacion + 2) % 4; }\n\n        avanzar_celda_pid(VEL_SPEED_RUN);\n\n        if (orientacion == NORTE) robot_y++;\n        else if (orientacion == SUR) robot_y--;\n        else if (orientacion == ESTE) robot_x++;\n        else if (orientacion == OESTE) robot_x--;\n    }\n}\n\nint main() {\n    setup_system();\n    init_mapa();\n    sleep_ms(3000); \n\n    printf(\"--- FASE 1: EXPLORACION ---\\n\");\n\n    while (1) {\n        escanear_paredes();\n        actualizar_flood_fill(false); \n\n\n        if (mapa[robot_x][robot_y].distancia == 0) {\n            frenar_total();\n            printf(\"META ENCONTRADA. PREPARANDO FASE 2...\\n\");\n\n            for(int i=0; i&lt;4; i++) { girar_estatico(true); }\n\n            ejecutar_speed_run(); \n            break; \n        }\n\n        uint8_t min_dist = 255;\n\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_N) &amp;&amp; robot_y &lt; ALTO-1) if (mapa[robot_x][robot_y+1].distancia &lt; min_dist) min_dist = mapa[robot_x][robot_y+1].distancia;\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_E) &amp;&amp; robot_x &lt; ANCHO-1) if (mapa[robot_x+1][robot_y].distancia &lt; min_dist) min_dist = mapa[robot_x+1][robot_y].distancia;\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_S) &amp;&amp; robot_y &gt; 0) if (mapa[robot_x][robot_y-1].distancia &lt; min_dist) min_dist = mapa[robot_x][robot_y-1].distancia;\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_W) &amp;&amp; robot_x &gt; 0) if (mapa[robot_x-1][robot_y].distancia &lt; min_dist) min_dist = mapa[robot_x-1][robot_y].distancia;\n\n        int intentos[4] = {orientacion, (orientacion+1)%4, (orientacion+3)%4, (orientacion+2)%4};\n        int mejor_dir = -1;\n        bool encontrado_nuevo = false;\n\n        for(int i=0; i&lt;4; i++) {\n            int dir = intentos[i];\n            int nx = robot_x, ny = robot_y;\n            bool pared = false;\n            if (dir==NORTE) { ny++; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_N); }\n            else if (dir==ESTE) { nx++; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_E); }\n            else if (dir==SUR) { ny--; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_S); }\n            else if (dir==OESTE) { nx--; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_W); }\n\n            if (nx &gt;= 0 &amp;&amp; nx &lt; ANCHO &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; ALTO &amp;&amp; !pared) {\n                if (mapa[nx][ny].distancia == min_dist &amp;&amp; !mapa[nx][ny].visitada) {\n                    mejor_dir = dir; encontrado_nuevo = true; break;\n                }\n            }\n        }\n        if (!encontrado_nuevo) {\n            for(int i=0; i&lt;4; i++) {\n                int dir = intentos[i];\n                int nx = robot_x, ny = robot_y;\n                bool pared = false;\n                if (dir==NORTE) { ny++; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_N); }\n                else if (dir==ESTE) { nx++; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_E); }\n                else if (dir==SUR) { ny--; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_S); }\n                else if (dir==OESTE) { nx--; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_W); }\n\n                if (nx &gt;= 0 &amp;&amp; nx &lt; ANCHO &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; ALTO &amp;&amp; !pared) {\n                    if (mapa[nx][ny].distancia == min_dist) { mejor_dir = dir; break; }\n                }\n            }\n        }\n\n\n        centrar_frente_a_pared();\n\n        if (mejor_dir == -1) {\n            girar_estatico(true); girar_estatico(true);\n            orientacion = (orientacion + 2) % 4;\n        } else {\n            int diferencia = (mejor_dir - orientacion + 4) % 4;\n            if (diferencia == 1) { girar_estatico(true); orientacion = (orientacion + 1) % 4; }\n            else if (diferencia == 3) { girar_estatico(false); orientacion = (orientacion + 3) % 4; }\n            else if (diferencia == 2) { girar_estatico(true); girar_estatico(true); orientacion = (orientacion + 2) % 4; }\n        }\n\n        avanzar_celda_pid(VEL_EXPLORACION);\n\n        if (orientacion == NORTE) robot_y++;\n        else if (orientacion == SUR) robot_y--;\n        else if (orientacion == ESTE) robot_x++;\n        else if (orientacion == OESTE) robot_x--;\n\n        sleep_ms(50);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Proyecto/proyecto_final/#esquema","title":"Esquema","text":""},{"location":"Proyecto/proyecto_final/#video","title":"Video","text":""},{"location":"Tarea_1/ejemplo/","title":"\ud83d\udcbe Tabla comparativa de Microcontroladores","text":"<p>Selene Rom\u00e1n Celis - 27/08/2025</p>"},{"location":"Tarea_1/ejemplo/#pulsera-para-deteccion-de-hipoglucemia-nocturna","title":"Pulsera para detecci\u00f3n de hipoglucemia nocturna","text":"<p>La idea es un wearable que detecte signos fisiol\u00f3gicos de hipoglucemia nocturna usando sensores y un microcontrolador. Cuando identifica un episodio, la pulsera despierta al paciente mediante vibraci\u00f3n, alarma sonora o incluso enviando una alerta al celular de un familiar.</p>"},{"location":"Tarea_1/ejemplo/#microcontroladores","title":"Microcontroladores","text":"<ul> <li>Seeed Studio XIAO nRF52840 Sense</li> <li>ESP32-C3</li> <li>Raspberry Pi Pico 2 (RP2350)</li> <li>nRF52840 Pro Micro</li> </ul>"},{"location":"Tarea_1/ejemplo/#tabla-comparativa","title":"Tabla comparativa","text":"Caracter\u00edstica Raspberry Pi Pico 2 XIAO nRF52840 Sense ESP32-C3 NRF52840 Pro-Micro Perif\u00e9ricos UART, SPI, I2C, PWM, PHY USB 1.1, PIO UART, IIC, SPI, NFC, SWD, GPIO, ADC GPIO, ADC, UART, I2C, SPI ADC, PWM, SPI, I2C, UART, USB, GPIO Memoria SRAM: 520 KBFlash: 4 MB RAM: 256 KBFlash: 1 MBQSPI: 2 MB SRAM: 400 KBFlash: 4 MB Flash: 1 MBRAM: 256 KB Ecosistema Python, C/C++ Arduino, Mbed, Zephyr ESP-IDF, Arduino, Mbed Arduino, Zephyr Costos $150\u2013$180 $300\u2013$500 $80\u2013$100 $170\u2013$200 Arquitectura Cortex-M33 Cortex-M4 RISC-V Cortex-M4 Velocidad de trabajo 150 MHz 64 MHz 160 MHz 64 MHz"},{"location":"Tarea_1/ejemplo/#ranking","title":"Ranking","text":"<p>1. Seeed Studio XIAO nRF52840 Sense :Este microcontrolador es la mejor opci\u00f3n para el proyecto por su tama\u00f1o compacto y gran potencia para procesar los datos de los sensores. Adem\u00e1s, ya incluye modulo Bluetooth, lo cual es esencial para enviar las alertas a un celular cercano.</p> <p>2. ESP32-C3 :Tiene como ventaja que incorpora Wi-fi y Bluetooth, lo que permite que la pulsera pueda enviar datos a un servidos en tiempo real. Adem\u00e1s es muy econ\u00f3mico. Tiene mayor consumo energ\u00e9tico a comparaci\u00f3n del XIAO nRF52840.</p> <p>3. Raspberry Pi Pico 2 (RP2350) :Tiene una gran potencia de procesamiento y es econ\u00f3mica. Se tendr\u00eda que a\u00f1adir un m\u00f3dulo BLE o Wi-Fi, lo que incrementa el tama\u00f1o y consumo. </p> <p>4. nRF5284O Pro - Micro :Est\u00e1 basado en el mismo chip nRF52840 que el XIAO, pero en un formato m\u00e1s grande y con menos integraci\u00f3n de sensores. Aun as\u00ed, tiene BLE integrado y un buen desempe\u00f1o.</p>"},{"location":"Tarea_2/barrido/","title":"\ud83d\udd1b Barrido de leds","text":"<p>Selene Rom\u00e1n Celis - 27/08/2025 </p>"},{"location":"Tarea_2/barrido/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Correr un \u201c1\u201d por cinco LEDs P0..P3 y regresar (0\u21921\u21922\u21923\u21922\u21921\u2026)</p>"},{"location":"Tarea_2/barrido/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\n#define LED0 0\n#define LED1 1\n#define LED2 2\n#define LED3 3\n\nint main() {\n   // M\u00e1scara\n   const uint32_t MASK = (1u&lt;&lt;LED0) | (1u&lt;&lt;LED1) | (1u&lt;&lt;LED2) | (1u&lt;&lt;LED3);\n\n   // Inicializar pines\n   gpio_init(LED0);\n   gpio_init(LED1);\n   gpio_init(LED2);\n   gpio_init(LED3);\n\n   // Configurar como salida\n   sio_hw-&gt;gpio_oe_set = MASK;\n\n   int pos = 0;       // LED inicial\n   int dir = 1;       // Direcci\u00f3n: 1\u2192derecha, -1\u2192izquierda\n\n   while (true) {\n       // Apagar todos\n       sio_hw-&gt;gpio_clr = MASK;\n\n       // Encender solo el LED actual\n       sio_hw-&gt;gpio_set = (1u &lt;&lt; pos);\n\n       sleep_ms(200);\n\n       // Mover posici\u00f3n\n       pos += dir;\n\n       // Rebotar en los extremos\n       if (pos == 3) dir = -1;  \n       if (pos == 0) dir = 1;\n   }\n}\n</code></pre>"},{"location":"Tarea_2/barrido/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Tarea_2/barrido/#video","title":"Video","text":""},{"location":"Tarea_2/contador/","title":"\ud83c\udfb2 Contador binario 4 bits","text":"<p>Selene Rom\u00e1n Celis - 27/08/2025</p>"},{"location":"Tarea_2/contador/#que-debe-hacer","title":"Que debe hacer","text":"<p>En cuatro leds debe mostrarse cada segundo la representaci\u00f3n binaria del 0 al 15.</p>"},{"location":"Tarea_2/contador/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define PIN_A 0\n#define PIN_B 1\n#define PIN_C 2\n#define PIN_D 3\n\nint main() {\n\n   // M\u00e1scara\n   const uint32_t MASK = (1u&lt;&lt;PIN_A) | (1u&lt;&lt;PIN_B) | (1u&lt;&lt;PIN_C) | (1u&lt;&lt;PIN_D);\n\n   gpio_init_mask(MASK);\n   gpio_set_dir_out_masked(MASK);\n\n   while (true) {\n       for (int i = 0; i &lt; 16; i++) {   // Cuenta de 0 a 15\n           gpio_put_masked(MASK, i &lt;&lt; PIN_A);\n\n           sleep_ms(1000);                  \n       }\n   }\n}\n</code></pre>"},{"location":"Tarea_2/contador/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Tarea_2/contador/#video","title":"Video","text":""},{"location":"Tarea_2/gray/","title":"\ud83d\udcf6 Secuencia en c\u00f3digo Gray","text":"<p>Selene Rom\u00e1n Celis - 27/08/2025</p>"},{"location":"Tarea_2/gray/#pulsera-para-deteccion-de-hipoglucemia-nocturna","title":"Pulsera para detecci\u00f3n de hipoglucemia nocturna","text":"<p>La idea es un wearable que detecte signos fisiol\u00f3gicos de hipoglucemia nocturna usando sensores y un microcontrolador. Cuando identifica un episodio, la pulsera despierta al paciente mediante vibraci\u00f3n, alarma sonora o incluso enviando una alerta al celular de un familiar.</p>"},{"location":"Tarea_2/gray/#microcontroladores","title":"Microcontroladores","text":"<ul> <li>Seeed Studio XIAO nRF52840 Sense</li> <li>ESP32-C3</li> <li>Raspberry Pi Pico 2 (RP2350)</li> <li>nRF52840 Pro Micro</li> </ul>"},{"location":"Tarea_2/gray/#tabla-comparativa","title":"Tabla comparativa","text":"Caracter\u00edstica Raspberry Pi Pico 2 XIAO nRF52840 Sense ESP32-C3 NRF52840 Pro-Micro Perif\u00e9ricos UART, SPI, I2C, PWM, PHY USB 1.1, PIO UART, IIC, SPI, NFC, SWD, GPIO, ADC GPIO, ADC, UART, I2C, SPI ADC, PWM, SPI, I2C, UART, USB, GPIO Memoria SRAM: 520 KBFlash: 4 MB RAM: 256 KBFlash: 1 MBQSPI: 2 MB SRAM: 400 KBFlash: 4 MB Flash: 1 MBRAM: 256 KB Ecosistema Python, C/C++ Arduino, Mbed, Zephyr ESP-IDF, Arduino, Mbed Arduino, Zephyr Costos $150\u2013$180 $300\u2013$500 $80\u2013$100 $170\u2013$200 Arquitectura Cortex-M33 Cortex-M4 RISC-V Cortex-M4 Velocidad de trabajo 150 MHz 64 MHz 160 MHz 64 MHz"},{"location":"Tarea_2/gray/#ranking","title":"Ranking","text":"<p>1. Seeed Studio XIAO nRF52840 Sense :Este microcontrolador es la mejor opci\u00f3n para el proyecto por su tama\u00f1o compacto y gran potencia para procesar los datos de los sensores. Adem\u00e1s, ya incluye modulo Bluetooth, lo cual es esencial para enviar las alertas a un celular cercano.</p> <p>2. ESP32-C3 :Tiene como ventaja que incorpora Wi-fi y Bluetooth, lo que permite que la pulsera pueda enviar datos a un servidos en tiempo real. Adem\u00e1s es muy econ\u00f3mico. Tiene mayor consumo energ\u00e9tico a comparaci\u00f3n del XIAO nRF52840.</p> <p>3. Raspberry Pi Pico 2 (RP2350) :Tiene una gran potencia de procesamiento y es econ\u00f3mica. Se tendr\u00eda que a\u00f1adir un m\u00f3dulo BLE o Wi-Fi, lo que incrementa el tama\u00f1o y consumo. </p> <p>4. nRF5284O Pro - Micro :Est\u00e1 basado en el mismo chip nRF52840 que el XIAO, pero en un formato m\u00e1s grande y con menos integraci\u00f3n de sensores. Aun as\u00ed, tiene BLE integrado y un buen desempe\u00f1o.</p>"},{"location":"Tarea_3/barrido_boton/","title":"\ud83d\udd79\ufe0f Selector c\u00edclico de 4 LEDs con avance/retroceso","text":"<p>Selene Rom\u00e1n Celis - 01/09/2025 </p>"},{"location":"Tarea_3/barrido_boton/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Con dos botones A y B (pull-up; presionado=0) enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. En el video muestra las 4 combinaciones (00, 01, 10, 11).</p> <pre><code>#include \"pico/stdlib.h\"\n\n#define LED0 0\n#define LED1 1\n#define LED2 2\n#define LED3 3\n#define B_AV 4\n#define B_RE 5\n\nint main() {\n    // M\u00e1scara\n    const uint32_t LEDS_MASK = (1u&lt;&lt;LED0) | (1u&lt;&lt;LED1) | (1u&lt;&lt;LED2) | (1u&lt;&lt;LED3);\n\n    gpio_init(LED0);\n    gpio_init(LED1);\n    gpio_init(LED2);\n    gpio_init(LED3);\n    gpio_set_dir(LED0, true);\n    gpio_set_dir(LED1, true);\n    gpio_set_dir(LED2, true);\n    gpio_set_dir(LED3, true);\n\n    gpio_init(B_AV);\n    gpio_init(B_RE);\n    gpio_set_dir(B_AV, false);\n    gpio_set_dir(B_RE, false);\n    gpio_pull_up(B_AV);\n    gpio_pull_up(B_RE);\n\n    int pos = 0;        \n    int estadoAV = 1;   // Estado previo bot\u00f3n A\n    int estadoRE = 1;   // Estado previo bot\u00f3n B\n\n    while (true) {\n\n        gpio_put_masked(LEDS_MASK, (1u &lt;&lt; pos));\n\n        if (gpio_get(B_AV) == 0 &amp;&amp; estadoAV == 1) {\n            pos++;\n            if (pos &gt; 3) pos = 0;\n        }\n        else if (gpio_get(B_RE) == 0 &amp;&amp; estadoRE == 1) {\n            pos--;\n            if (pos &lt; 0) pos = 3;\n        }\n        // Guardar estado\n        estadoAV = gpio_get(B_AV);\n        estadoRE = gpio_get(B_RE);\n\n        sleep_ms(20);\n    }\n}\n</code></pre>"},{"location":"Tarea_3/barrido_boton/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Tarea_3/barrido_boton/#video","title":"Video","text":""},{"location":"Tarea_3/compuertas/","title":"\ud83d\uddb2\ufe0f Compuertas b\u00e1sicas AND / OR / XOR con 2 botones","text":"<p>Selene Rom\u00e1n Celis - 01/09/2025 </p>"},{"location":"Tarea_3/compuertas/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Con dos botones A y B (pull-up; presionado=0) enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. En el video muestra las 4 combinaciones (00, 01, 10, 11).</p> <pre><code>#include \"pico/stdlib.h\"\n\n#define BTN_A   5   \n#define BTN_B   4   \n#define LED_AND 0   \n#define LED_OR  1   \n#define LED_XOR 2   \n\nint main() {\n\n    const uint32_t BTN_MASK = (1u &lt;&lt; BTN_A) | (1u &lt;&lt; BTN_B);\n    const uint32_t LED_MASK = (1u &lt;&lt; LED_AND) | (1u &lt;&lt; LED_OR) | (1u &lt;&lt; LED_XOR);\n\n    gpio_init_mask(BTN_MASK | LED_MASK);\n    gpio_set_dir_out_masked(LED_MASK);  \n    gpio_set_dir_in_masked(BTN_MASK);   \n    gpio_pull_up(BTN_A);\n    gpio_pull_up(BTN_B);\n\n    while (true) {\n\n        int a = !gpio_get(BTN_A);\n        int b = !gpio_get(BTN_B);\n\n\n        int val_and = a &amp; b;\n        int val_or  = a | b;\n        int val_xor = a ^ b;\n\n\n        uint32_t leds = (val_and &lt;&lt; LED_AND) | (val_or &lt;&lt; LED_OR) | (val_xor &lt;&lt; LED_XOR);\n\n        gpio_put_masked(LED_MASK, leds);\n\n        sleep_ms(20);\n    }\n}\n</code></pre>"},{"location":"Tarea_3/compuertas/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Tarea_3/compuertas/#video","title":"Video","text":""},{"location":"Tarea_4/pinpong/","title":"\ud83c\udfd3 Mini-Pong","text":"<p>Selene Rom\u00e1n Celis - 04/09/2025 </p>"},{"location":"Tarea_4/pinpong/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Programar un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado.</p> <p>Reglas del juego</p> <ol> <li> <p>Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (L1\u2192L5\u2192L1\u2026) a un ritmo fijo.</p> </li> <li> <p>Golpe con ISR: cada bot\u00f3n genera una interrupci\u00f3n.</p> <ul> <li> <p>El BTN_L solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.</p> </li> <li> <p>El BTN_R solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.</p> </li> <li> <p>Si coincide, la pelota rebota: invierte su direcci\u00f3n.</p> </li> <li> <p>Si no coincide (la pelota no est\u00e1 en el \u00faltimo LED de ese lado), el bot\u00f3n se ignora.</p> </li> </ul> </li> <li> <p>Fallo y punto: si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza L5 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> </li> <li> <p>Indicador de punto: al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto .</p> </li> <li> <p>Reinicio tras punto: despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> </li> <li> <p>Inicio del juego: al encender, la pelota inicia en L3 y no se mueve hasta que se presione un boton y debera moverse a la direccion opuesta del boton presionado.</p> </li> </ol>"},{"location":"Tarea_4/pinpong/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"   \n\n#define LED_1 0\n#define LED_2 1\n#define LED_3 2\n#define LED_4 3\n#define LED_5 4\n\n#define LED_J1 5\n#define LED_J2 6\n\n#define B_D 7\n#define B_I 8\n\nint led_on = 2;\nint direc = 0;\nint boton_d = 0;\nint boton_i = 0;\n\n\nvoid botones(uint gpio, uint32_t events) {\n    if (gpio == B_D) boton_d = 1;\n    if (gpio == B_I) boton_i = 1;\n}\n\nvoid parpadeo(int led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(300);\n        gpio_put(led, 0);\n        sleep_ms(300);\n    }\n}\n\nvoid init_leds() {\n    gpio_init(LED_1);\n    gpio_set_dir(LED_1, 1);\n    gpio_init(LED_2);\n    gpio_set_dir(LED_2, 1);\n    gpio_init(LED_3);\n    gpio_set_dir(LED_3, 1);\n    gpio_init(LED_4); \n    gpio_set_dir(LED_4, 1);\n    gpio_init(LED_5); \n    gpio_set_dir(LED_5, 1);\n    gpio_init(LED_J1); \n    gpio_set_dir(LED_J1, 1);\n    gpio_init(LED_J2); \n    gpio_set_dir(LED_J2, 1);\n}\n\nvoid init_botones() {\n    gpio_init(B_D); \n    gpio_set_dir(B_D, 0);\n    gpio_pull_up(B_D);\n\n    gpio_init(B_I); \n    gpio_set_dir(B_I, 0);\n    gpio_pull_up(B_I);\n\n    // Interrupciones para botones\n    gpio_set_irq_enabled_with_callback(B_D, GPIO_IRQ_EDGE_FALL, true, &amp;botones);\n    gpio_set_irq_enabled(B_I, GPIO_IRQ_EDGE_FALL, true); \n}\n\nint main() {\n    stdio_init_all(); \n    init_leds();\n    init_botones();\n\n\n    while (direc == 0) {\n        gpio_put(LED_3, 1);\n        if (boton_d) { direc = 1; boton_d = 0; }\n        if (boton_i) { direc = -1; boton_i = 0; }\n        sleep_ms(10);\n    }\n\n    while (true) {\n        // Apagar LED\n        gpio_put(LED_1, 0); gpio_put(LED_2, 0); gpio_put(LED_3, 0);\n        gpio_put(LED_4, 0); gpio_put(LED_5, 0);\n\n        gpio_put(led_on, 1);\n        sleep_ms(500);\n\n        if (led_on == LED_1) {\n            if (boton_d) direc = 1;\n            else {\n                 parpadeo(LED_J2); led_on = LED_2; direc = 1; \n                }\n            boton_d = 0;\n        } \n        else if (led_on == LED_5) {\n            if (boton_i) direc = -1;\n            else { \n                parpadeo(LED_J1); led_on = LED_4; direc = -1; \n            }\n            boton_i = 0;\n        }\n\n        led_on += direc;\n    }\n}\n</code></pre>"},{"location":"Tarea_4/pinpong/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Tarea_4/pinpong/#video","title":"Video","text":""},{"location":"Tarea_5/Ejercicio_1/","title":"\u23f1\ufe0f Medici\u00f3n en osciloscopio del periodo y jitter usando ALARM0 (modo \u00b5s)","text":"<p>Selene Rom\u00e1n Celis - 15/09/2025 </p>"},{"location":"Tarea_5/Ejercicio_1/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio:</p> <ul> <li> <p>Periodo promedio y tolerancia.</p> </li> <li> <p>Jitter pico-a-pico y, si tu equipo lo permite, RMS.</p> </li> <li> <p>Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s).</p> </li> </ul>"},{"location":"Tarea_5/Ejercicio_1/#codigo","title":"C\u00f3digo","text":"<p><pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 0\nstatic const int BLINK_MS = 50; \n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre> Para comprobar el funcionamiento del generador de onda cuadrada mediante el toggle de un pin de salida controlado por la ISR de ALARM0, se realiz\u00f3 la medici\u00f3n con el osciloscopio Tektronix (modelo digital). Se configur\u00f3 el rearme acumulativo de la alarma con un periodo nominal definido en 50 ms.</p> <p>En el esquema se muestra la forma de onda obtenida del osciloscopio.</p>"},{"location":"Tarea_5/Ejercicio_1/#esquema","title":"Esquema","text":"<ul> <li>Periodo promedio medido: 49.94 ms</li> <li>Tolerancia: aproximadamente \u00b10.56 ms</li> <li>Jitter pico-a-pico: ~560 \u00b5s</li> </ul> <ul> <li>Acoplamiento: CC</li> <li>Escala de tiempo: 20 ms/div y 10 ms/div</li> <li>Escala de voltaje: 1 V/div.</li> <li>Modo de disparo: flanco, canal 1, nivel medio de la se\u00f1al (~1.3 V)</li> </ul>"},{"location":"Tarea_5/Ejercicio_2/","title":"\u23f1\ufe0f\ud83d\udd04 Comparar jitter/precisi\u00f3n con osciloscopio: modo \u00b5s vs modo ciclos","text":"<p>Selene Rom\u00e1n Celis - 15/09/2025 </p>"},{"location":"Tarea_5/Ejercicio_2/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> <ul> <li> <p>Usa rearme acumulativo.</p> </li> <li> <p>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico.</p> </li> <li> <p>Con el osciloscopio, mide y registra para cada modo:</p> <ul> <li>Periodo promedio y desviaci\u00f3n respecto al nominal.</li> <li>Jitter pico-a-pico y/o RMS.</li> <li>Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.</li> </ul> </li> </ul>"},{"location":"Tarea_5/Ejercicio_2/#codigo-modo-s","title":"C\u00f3digo modo \u00b5s","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 0\nstatic const int BLINK_MS = 50; \n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Tarea_5/Ejercicio_2/#codigo-modo-ciclos","title":"C\u00f3digo modo ciclos","text":"<pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       0\n#define ALARM_NUM     0 \n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 50000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1. Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2. Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3. Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre> <p>Se gener\u00f3 una se\u00f1al cuadrada mediante el toggle de un pin en la ISR de ALARM0, empleando rearme acumulativo. Se program\u00f3 el mismo periodo nominal en dos configuraciones:</p> <ol> <li> <p>Modo \u00b5s (resoluci\u00f3n en microsegundos).</p> </li> <li> <p>Modo ciclos de clk_sys (resoluci\u00f3n en ciclos de reloj).</p> </li> </ol> <p>En ambos casos se mantuvo id\u00e9ntico el resto del c\u00f3digo.</p>"},{"location":"Tarea_5/Ejercicio_2/#esquema-modo-s","title":"Esquema modo \u00b5s","text":""},{"location":"Tarea_5/Ejercicio_2/#esquema-modo-ciclos","title":"Esquema modo ciclos","text":""},{"location":"Tarea_5/Ejercicio_2/#resultado-de-medicion-con-osciloscopio","title":"Resultado de medici\u00f3n con osciloscopio","text":"<ol> <li>Modo \u00b5s<ul> <li>Periodo nominal configurado: 50 ms</li> <li>Periodo promedio medido: 49.94 ms</li> <li>Desviaci\u00f3n: ~1.1%</li> <li>Jitter pico-a-pico: ~560 \u00b5s</li> </ul> </li> </ol> <ol> <li>Modo ciclos<ul> <li>Periodo nominal configurado: 50 000 (Periodo en ms)</li> <li>Periodo promedio medido: 49.96 ms</li> <li>Desviaci\u00f3n: ~0.08%</li> <li>Jitter pico-a-pico: ~14 \u00b5s</li> </ul> </li> </ol> <p>En modo \u00b5s, el temporizador est\u00e1 limitado por la resoluci\u00f3n del tick de microsegundo. Esto produce un jitter m\u00e1s grande. La ventaja es que permite programar periodos largos sin desbordar el contador.</p> <p>En modo ciclos, la resoluci\u00f3n es mucho m\u00e1s fina. El resultado es un jitter significativamente menor y una desviaci\u00f3n m\u00e1s peque\u00f1a respecto al periodo nominal. Sin embargo, el horizonte de programaci\u00f3n es m\u00e1s corto, el contador puede desbordarse m\u00e1s r\u00e1pido si se intentan programar retardos largos \u00fanicamente con ciclos.</p>"},{"location":"Tarea_6/Ejercicio_1_6/","title":"\ud83d\udca1 Cuatro alarmas / LEDs a distintas frecuencias","text":"<p>Selene Rom\u00e1n Celis - 17/09/2025 </p>"},{"location":"Tarea_6/Ejercicio_1_6/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Configurar ALARM0..ALARM3 del timer de sistema en modo \u00b5s. Cada alarma controla un LED distinto con un periodo propio. </p>"},{"location":"Tarea_6/Ejercicio_1_6/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN0      0\n#define LED_PIN1      1\n#define LED_PIN2      2\n#define LED_PIN3      3\n\n\n#define ALARM_NUM0     0  // usaremos la alarma 0\n#define ALARM_NUM1     1\n#define ALARM_NUM2     2\n#define ALARM_NUM3     3\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM0_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM0)\n\nstatic volatile uint32_t next_deadline[4];   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us[4]=  { // periodo en microsegundos\n    50000u,\n    100000u,\n    150000u,\n    200000u  \n};\n\nvoid on_alarm_irq(void) {\n    if (timer_hw-&gt;intr &amp; (1u &lt;&lt; ALARM_NUM0)) {\n        hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM0);\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN0;\n        next_deadline[0] += intervalo_us[0];\n        timer_hw-&gt;alarm[ALARM_NUM0] = next_deadline[0];\n    }\n\n    if (timer_hw-&gt;intr &amp; (1u &lt;&lt; ALARM_NUM1)) {\n        hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM1);\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN1;\n        next_deadline[1] += intervalo_us[1];\n        timer_hw-&gt;alarm[ALARM_NUM1] = next_deadline[1];\n    }\n\n    if (timer_hw-&gt;intr &amp; (1u &lt;&lt; ALARM_NUM2)) {\n        hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM2);\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN2;\n        next_deadline[2] += intervalo_us[2];\n        timer_hw-&gt;alarm[ALARM_NUM2] = next_deadline[2];\n    }\n\n    if (timer_hw-&gt;intr &amp; (1u &lt;&lt; ALARM_NUM3)) {\n        hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM3);\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN3;\n        next_deadline[3] += intervalo_us[3];\n        timer_hw-&gt;alarm[ALARM_NUM3] = next_deadline[3];\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN0);\n    gpio_set_dir(LED_PIN0, true);\n    gpio_init(LED_PIN1);\n    gpio_set_dir(LED_PIN1, true);\n    gpio_init(LED_PIN2);\n    gpio_set_dir(LED_PIN2, true);\n    gpio_init(LED_PIN3);\n    gpio_set_dir(LED_PIN3, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n\n    next_deadline[0] = now_us + intervalo_us[0];\n    next_deadline[1] = now_us + intervalo_us[1];\n    next_deadline[2] = now_us + intervalo_us[2];\n    next_deadline[3] = now_us + intervalo_us[3];      \n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM0] = next_deadline[0];\n    timer_hw-&gt;alarm[ALARM_NUM1] = next_deadline[1];\n    timer_hw-&gt;alarm[ALARM_NUM2] = next_deadline[2];\n    timer_hw-&gt;alarm[ALARM_NUM3] = next_deadline[3];\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM0_IRQ, on_alarm_irq);\n\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM0);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM1);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM2);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM3);\n\n   //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM0_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Tarea_6/Ejercicio_1_6/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Tarea_6/Ejercicio_1_6/#video","title":"Video","text":""},{"location":"Tarea_6/Ejercicio_2_6/","title":"\u23ea\u23e9\ufe0f Mini-Pong 2.0","text":"<p>Selene Rom\u00e1n Celis - 17/09/2025 </p>"},{"location":"Tarea_6/Ejercicio_2_6/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Modificar el Mini-Pong, para tener dos botones adicionales, que suban y bajen la velocidad del juego sin delay.</p>"},{"location":"Tarea_6/Ejercicio_2_6/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define LED_1 0\n#define LED_2 1\n#define LED_3 2\n#define LED_4 3\n#define LED_5 4\n\n#define LED_J1 16\n#define LED_J2 17\n\n#define B_D 14\n#define B_I 15\n\n#define B_UP 18\n#define B_DOWN 19\n\nint led_on = 2;\nint direc = 0;\nint boton_d = 0;\nint boton_i = 0;\n\n\nint velocidad = 600;\nconst int MIN = 400;\nconst int MAX = 1500;\nconst int Aumento = 50;\n\n\n#define ALARM1_NUM 1\n#define ALARM1_IRQ timer_hardware_alarm_get_irq_num(timer_hw, ALARM1_NUM)\nstatic uint32_t next1;\n\nvoid botones(uint gpio, uint32_t events) {\n    if (gpio == B_D) boton_d = 1;\n    if (gpio == B_I) boton_i = 1;\n}\n\nstatic void alarmvel_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM1_NUM);\n\n    int up = gpio_get(B_UP);\n    int down = gpio_get(B_DOWN);\n\n    if (!up) { // Aumentar velocidad\n        if (velocidad &gt; MIN + Aumento) velocidad -= Aumento;\n        else velocidad = MIN;\n    }\n    if (!down) { // Bajar velocidad\n        if (velocidad &lt; MAX - Aumento) velocidad += Aumento;\n        else velocidad = MAX;\n    }\n\n    next1 += 20000;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1;\n}\n\nvoid parpadeo(int led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(300);\n        gpio_put(led, 0);\n        sleep_ms(300);\n    }\n}\n\nvoid leds() {\n    int leds[] = {LED_1, LED_2, LED_3, LED_4, LED_5, LED_J1, LED_J2};\n    for (int i = 0; i &lt; 7; ++i) {\n        gpio_init(leds[i]);\n        gpio_set_dir(leds[i], GPIO_OUT);\n        gpio_put(leds[i], 0);\n    }\n}\n\nvoid iniciar_botones() {\n    int botones_dir[] = {B_D, B_I};\n    for (int i = 0; i &lt; 2; ++i) {\n        gpio_init(botones_dir[i]);\n        gpio_set_dir(botones_dir[i], GPIO_IN);\n        gpio_pull_up(botones_dir[i]);\n    }\n\n    gpio_set_irq_enabled_with_callback(B_D, GPIO_IRQ_EDGE_FALL, true, &amp;botones);\n    gpio_set_irq_enabled(B_I, GPIO_IRQ_EDGE_FALL, true);\n}\n\nvoid botones_velocidad() {\n    int botones_vel[] = {B_UP, B_DOWN};\n    for (int i = 0; i &lt; 2; ++i) {\n        gpio_init(botones_vel[i]);\n        gpio_set_dir(botones_vel[i], GPIO_IN);\n        gpio_pull_up(botones_vel[i]);\n    }\n\n    timer_hw-&gt;source = 0u;\n    uint32_t now = timer_hw-&gt;timerawl;\n    next1 = now + 20000;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1;\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM1_NUM);\n    irq_set_exclusive_handler(ALARM1_IRQ, alarmvel_irq);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM1_NUM);\n    irq_set_enabled(ALARM1_IRQ, true);\n}\n\nint main() {\n    stdio_init_all();\n    leds();\n    iniciar_botones();\n    botones_velocidad();\n\n    gpio_put(LED_3, 1);\n    while (direc == 0) {\n        if (boton_d) { direc = 1; boton_d = 0; gpio_put(LED_3, 0); }\n        if (boton_i) { direc = -1; boton_i = 0; gpio_put(LED_3, 0); }\n        sleep_ms(10);\n    }\n\n    while (true) {\n        gpio_put(LED_1, 0); \n        gpio_put(LED_2, 0); \n        gpio_put(LED_3, 0);\n        gpio_put(LED_4, 0); \n        gpio_put(LED_5, 0);\n\n        gpio_put(led_on, 1);\n        sleep_ms(velocidad);\n\n        if (led_on == LED_1) {\n            if (boton_d) direc = 1;\n            else { \n                parpadeo(LED_J2); led_on = LED_2; direc = 1; \n            }\n            boton_d = 0;\n        } \n        else if (led_on == LED_5) {\n            if (boton_i) direc = -1;\n            else { \n                parpadeo(LED_J1); led_on = LED_4; direc = -1; \n            }\n            boton_i = 0;\n        }\n\n        led_on += direc;\n    }\n}\n</code></pre>"},{"location":"Tarea_6/Ejercicio_2_6/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Tarea_6/Ejercicio_2_6/#video","title":"Video","text":""},{"location":"Tarea_7/buzzer_s/","title":"\ud83c\udfb6 Control de Frecuencia \u2014 Canci\u00f3n con Buzzer","text":"<p>Selene Rom\u00e1n Celis - 01/10/2025 </p>"},{"location":"Tarea_7/buzzer_s/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<ul> <li> <p>Programar un buzzer piezoel\u00e9ctrico para reproducir una melod\u00eda reconocible.</p> </li> <li> <p>Variar la frecuencia del PWM para las notas, manteniendo el duty en 50 %.</p> </li> <li> <p>Cada nota debe incluir su frecuencia y duraci\u00f3n en el c\u00f3digo.</p> </li> </ul> <p>Recomendaci\u00f3n</p> <p>La mejor frecuencia de trabajo del buzzer es t\u00edpicamente entre 532 Hz y 4 kHz y adaptar las notas a una octava que suene clara en ese rango.</p>"},{"location":"Tarea_7/buzzer_s/#notas-y-frecuencias-definidas","title":"Notas y Frecuencias Definidas","text":"Nota Frecuencia (Hz) DO 588.0 Hz MI 660.0 Hz FA 700.0 Hz FA# 740.0 Hz SOL 800.0 Hz LA 880.0 Hz SI 1000.0 Hz"},{"location":"Tarea_7/buzzer_s/#tiempos-de-duracion-definidos","title":"Tiempos de duraci\u00f3n definidos","text":"Identificador Duraci\u00f3n (ms) <code>time_1</code> 200 ms <code>time_2</code> 400 ms <code>time_3</code> 600 ms <code>time_e</code> (pausa) 200 ms <code>time_p</code> (pausa m\u00e1s larga) 300 ms"},{"location":"Tarea_7/buzzer_s/#secuencia-de-notas","title":"Secuencia de notas","text":"Estrofa Secuencia de Notas 1 Si - Si 2 La - Sol - La - Si - Sol 3 La - Sol - Fa# - Si - Sol 4 La - Sol - Fa# - Si - Do - Do - Si - Sol - Fa 5 La - Sol - Fa - Sol - La - Fa 6 Sol - Fa - Mi - La - Fa 7 Sol - Fa - Mi - La - Fa - Do - Si - La - Fa"},{"location":"Tarea_7/buzzer_s/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define BUZ_PIN 0\n#define SOL 800.0f\n#define SI  1000.0f\n#define DO  588.0f\n#define FA  700.0f\n#define FAS 740.0f\n#define MI  660.0f\n#define LA  880.0f\n#define TOP 1023\n\n#define time_1 200\n#define time_2 400\n#define time_3 600\n\n#define time_e 200\n#define time_p 300\n\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(BUZ_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(BUZ_PIN);\n    uint chan  = pwm_gpio_to_channel(BUZ_PIN);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_enabled(slice, true);\n\n    float f_clk = 150000000.0f; // 150 MHz\n\n    while (true) {\n\n    //Primera\n    float div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_3);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_3);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    //Segunda\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    //Tercera\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FAS * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    //Cuarta\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FAS * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (DO * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (DO * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_3);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    //Quinta\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_3);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    //Sexta\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (MI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    //Septima\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (MI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (DO * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    }\n}\n</code></pre>"},{"location":"Tarea_7/buzzer_s/#video","title":"Video","text":""},{"location":"Tarea_7/motor/","title":"\u2699\ufe0f Control de Duty Cycle \u2014 Motor DC","text":"<p>Selene Rom\u00e1n Celis - 01/10/2025 </p>"},{"location":"Tarea_7/motor/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<ul> <li> <p>Implementar un circuito con un motor DC controlado mediante PWM variando el duty cycle.</p> </li> <li> <p>Usar 2 botones para seleccionar entre 3 velocidades predefinidas (baja, media y alta).</p> </li> </ul> <p>Nota</p> <p>No olvidar que el microcontrolador no entrega suficiente potencia, se debe usar un puente H o driver de motor para conectar el motor DC.</p>"},{"location":"Tarea_7/motor/#valores-de-duty","title":"Valores de Duty","text":"<ul> <li> <p>Velocidad Alta = TOP - Cuando el duty esta en 100%, la se\u00f1al PWM est\u00e1 siempre en nivel alto.</p> <ul> <li> <p>max_level = 1023</p> </li> <li> <p>Duty m\u00e1ximo 1023 / 1023 = 100%</p> </li> </ul> </li> <li> <p>Velocidad Media = TOP/2 - Con un duty del 50%, la se\u00f1al PWM est\u00e1 en alto solo en la mitad del tiempo.</p> <ul> <li> <p>max_level = 511</p> </li> <li> <p>Duty m\u00e1ximo 511 / 1023 \u2248 50%</p> </li> </ul> </li> <li> <p>Velocidad Baja = TOP/4 - Con un duty del 25%, la se\u00f1al PWM solo est\u00e1 en alto una cuarta parte del ciclo.</p> <ul> <li> <p>max_level = 255</p> </li> <li> <p>Duty m\u00e1ximo 255 / 1023 \u2248 25%</p> </li> </ul> </li> </ul>"},{"location":"Tarea_7/motor/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define MOTOR_PIN 0\n#define B_UP 1\n#define B_DOWN 2\n#define F_PWM_HZ 2000\n#define TOP 1023\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(MOTOR_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(MOTOR_PIN);\n    uint chan  = pwm_gpio_to_channel(MOTOR_PIN);\n\n    float f_clk = 150000000.0f;\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    gpio_init(B_UP);\n    gpio_set_dir(B_UP, GPIO_IN); \n    gpio_pull_up(B_UP);\n    gpio_init(B_DOWN); \n    gpio_set_dir(B_DOWN, GPIO_IN); \n    gpio_pull_up(B_DOWN);\n\n\n    int level = 0, step = 8, dir = +step;\n    int max_level = TOP / 2; \n\n    while (true) {\n\n        if (!gpio_get(B_UP)) { \n            if (max_level &lt; TOP) max_level = TOP; \n            sleep_ms(200);\n        }\n        if (!gpio_get(B_DOWN)) { \n            if (max_level &gt; TOP/4) max_level = TOP/2; \n            else max_level = TOP/4; \n            sleep_ms(200);\n        }\n\n        if (level &gt;= max_level) dir = -step;\n        if (level &lt;= 0) dir = +step;\n\n        level += dir;\n\n        pwm_set_chan_level(slice, chan, level);\n        sleep_ms(5);\n    }\n\n}\n</code></pre>"},{"location":"Tarea_7/motor/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Tarea_7/motor/#video","title":"Video","text":""},{"location":"Tarea_7/senoidal/","title":"\u3030\ufe0f Generaci\u00f3n de Se\u00f1ales \u2014 Senoidal de 60 Hz con PWM + Filtro RC","text":"<p>Selene Rom\u00e1n Celis - 01/10/2025 </p>"},{"location":"Tarea_7/senoidal/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<ul> <li> <p>Generar una se\u00f1al sinusoidal aproximada de 60 Hz variando el duty cycle del PWM seg\u00fan una funci\u00f3n seno.</p> </li> <li> <p>Construir un filtro RC pasabajos b\u00e1sico y verificar la se\u00f1al en el osciloscopio</p> </li> </ul>"},{"location":"Tarea_7/senoidal/#codigo","title":"C\u00f3digo","text":"<p><pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;  \n\n#define LED_PIN 0\n#define F_PWM_HZ 100  \n#define TOP 1023        // 10 bits de resoluci\u00f3n\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(LED_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(LED_PIN);\n    uint chan  = pwm_gpio_to_channel(LED_PIN);\n\n    // Calcular divisor\n    float f_clk = 125000000.0f; // 125 MHz\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    float theta = 0.0f;\n    float dtheta = 0.05f;  \n\n    while (true) {\n\n        float s = (sinf(theta) + 1.0f) * 0.5f;\n        int level = (int)(s * TOP);\n\n        pwm_set_chan_level(slice, chan, level);\n\n        theta += dtheta;\n        if (theta &gt; 2.0f * M_PI) {\n            theta -= 2.0f * M_PI;\n        }\n\n        sleep_ms(5); \n    }\n}\n</code></pre> Valores para un fc\u2248100Hz - R=1.6\u2009k\u03a9R  - C=1\u2009\u03bcF  </p>"},{"location":"Tarea_7/senoidal/#osciloscopio-sin-filtro","title":"Osciloscopio sin Filtro","text":""},{"location":"Tarea_7/senoidal/#osciloscopio-con-filtro","title":"Osciloscopio con Filtro","text":""},{"location":"Tarea_8/UART1/","title":"\ud83d\uddb2\ufe0f\ud83d\udca1 Bot\u00f3n con instrucci\u00f3n \"LED ON - LED OFF\"","text":"<p>Selene Rom\u00e1n Celis - 22/10/2025 </p>"},{"location":"Tarea_8/UART1/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Este c\u00f3digo permite encender y apagar un LED mediante un bot\u00f3n f\u00edsico. Cada vez que se presiona el bot\u00f3n, el LED cambia de estado: si est\u00e1 apagado se enciende (\u201cLED ON\u201d) y si est\u00e1 encendido se apaga (\u201cLED OFF\u201d).</p>"},{"location":"Tarea_8/UART1/#codigo-envio","title":"C\u00f3digo Env\u00edo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define LED_PIN 14        \n#define BUTTON_PIN 3      \n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\nint main() {\n    stdio_init_all();\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    gpio_init(BUTTON_PIN);\n    gpio_set_dir(BUTTON_PIN, GPIO_IN);\n    gpio_pull_up(BUTTON_PIN);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    bool estado = false;\n    bool presionado_anterior = false;\n\n    while (true) {\n        bool presionado = !gpio_get(BUTTON_PIN);  \n\n        if (presionado &amp;&amp; !presionado_anterior) { \n            estado = !estado;  \n\n            if (estado) {\n                gpio_put(LED_PIN, 1);\n                uart_puts(UART_ID, \"LED ON\\n\");\n                printf(\"LED ON\\n\");\n            } else {\n                gpio_put(LED_PIN, 0);\n                uart_puts(UART_ID, \"LED OFF\\n\");\n                printf(\"LED OFF\\n\");\n            }\n\n            sleep_ms(200); \n        }\n\n        presionado_anterior = presionado;\n    }\n}\n</code></pre>"},{"location":"Tarea_8/UART1/#codigo-recepcion","title":"C\u00f3digo Recepci\u00f3n","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nstring mensaje = \"\";\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    printf(\"Esperando mensajes...\\n\");\n\n    while (true) {\n        if (uart_is_readable(UART_ID)) {\n            char ch = uart_getc(UART_ID);\n            printf(\"%c\", ch);\n            mensaje += ch;\n\n            if (ch == ';') {\n                string comando = mensaje.substr(0, mensaje.length() - 1);\n\n                if (comando == \"on\") {\n                    gpio_put(LED_PIN, 1);\n                    printf(\"\\nLED ENCENDIDO\\n\");\n                } else if (comando == \"off\") {\n                    gpio_put(LED_PIN, 0);\n                    printf(\"\\nLED APAGADO\\n\");\n                } else {\n                    printf(\"\\nMensaje no reconocido: '%s'\\n\", comando.c_str());\n                }\n\n                mensaje = \"\";\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Tarea_8/UART1/#video","title":"Video","text":""},{"location":"Tarea_8/UART2/","title":"\ud83d\udcbb\ud83d\udca1 Terminal con instrucci\u00f3n \"LED ON - LED OFF\"","text":"<p>Selene Rom\u00e1n Celis - 22/10/2025</p>"},{"location":"Tarea_8/UART2/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Este c\u00f3digo permite controlar el encendido y apagado de un LED desde el monitor serial. El usuario escribe los comandos \u201cLED ON\u201d o \u201cLED OFF\u201d en la terminal, y el microcontrolador ejecuta la acci\u00f3n correspondiente.</p>"},{"location":"Tarea_8/UART2/#codigo-recepcion","title":"C\u00f3digo Recepci\u00f3n","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nstring mensaje = \"\";\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    printf(\"Esperando mensajes...\\n\");\n\n    while (true) {\n        if (uart_is_readable(UART_ID)) {\n            char ch = uart_getc(UART_ID);\n            printf(\"%c\", ch);\n            mensaje += ch;\n\n            if (ch == ';') {\n                string comando = mensaje.substr(0, mensaje.length() - 1);\n\n                if (comando == \"on\") {\n                    gpio_put(LED_PIN, 1);\n                    printf(\"\\nLED ENCENDIDO\\n\");\n                } else if (comando == \"off\") {\n                    gpio_put(LED_PIN, 0);\n                    printf(\"\\nLED APAGADO\\n\");\n                } else {\n                    printf(\"\\nMensaje no reconocido: '%s'\\n\", comando.c_str());\n                }\n                mensaje = \"\";\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Tarea_8/UART2/#codigo-envio","title":"C\u00f3digo Env\u00edo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\nusing namespace std;\n\nstring mensaje = \"\";\n\nint main() {\n    stdio_init_all();\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    sleep_ms(2000);\n    printf(\"\\nConexi\u00f3n lista. Escribe 'on;' o 'off;'.\\n\");\n\n    while (true) {\n        int ch_int = getchar_timeout_us(10000);\n\n        if (ch_int == PICO_ERROR_TIMEOUT) {\n            continue;\n        }\n\n        char ch = (char)ch_int;\n\n        if (ch == '\\r' || ch == '\\n') {\n            continue;\n        }\n\n        mensaje += ch;\n\n        if (ch == ';') {\n            string comando = mensaje.substr(0, mensaje.length() - 1);\n\n            if (comando == \"on\" || comando == \"off\") {\n                printf(\"Instrucci\u00f3n: %s\\n\", mensaje.c_str());\n                uart_puts(UART_ID, mensaje.c_str());\n            } else {\n                printf(\"Instrucci\u00f3n inv\u00e1lida: '%s'\\n\", comando.c_str());\n            }\n\n            mensaje = \"\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Tarea_8/UART2/#video","title":"Video","text":""},{"location":"Tarea_9/luxometro/","title":"\ud83d\udd26 ADC L\u00faxometro","text":"<p>Selene Rom\u00e1n Celis - 03/11/2025 </p>"},{"location":"Tarea_9/luxometro/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Crear un codigo que me marca la luminosidad de 0-100% usando un LDR</p>"},{"location":"Tarea_9/luxometro/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n\n#define ADC_INPUT 1   \n#define N_muestras 16       \n\nint main() {\n    stdio_init_all();\n    adc_init();\n    adc_gpio_init(27); \n    adc_select_input(ADC_INPUT);\n\n    uint16_t buffer[N_muestras];\n    uint32_t sum = 0;\n    uint8_t indice = 0;\n    uint8_t cuenta = 0;\n\n    while (true) {\n        uint16_t adc = adc_read(); \n        if (cuenta &lt; N_muestras) {\n            buffer[indice] = adc;\n            sum += adc;\n            cuenta++;\n            indice++;\n        } else {\n            sum -= buffer[indice];\n            buffer[indice] = adc;\n            sum += adc;\n\n            indice++;\n            if (indice &gt;= N_muestras) indice = 0;\n\n            uint16_t promedio = sum / N_muestras;\n\n            float porcentaje = (promedio * 100.0f) / 4095;\n\n            printf(\"Luz: %u%%\\n\", (int)porcentaje);\n\n            sleep_ms(200);\n        }\n    }\n}\n</code></pre>"},{"location":"Tarea_9/luxometro/#esquema","title":"Esquema","text":""},{"location":"Tarea_9/luxometro/#video","title":"Video","text":""},{"location":"Tarea_9/servo_adc/","title":"\u23f2\ufe0f\u2699\ufe0f Servo con ADC","text":"<p>Selene Rom\u00e1n Celis - 03/11/2025 </p>"},{"location":"Tarea_9/servo_adc/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Crear un codigo para mover un servo usando un potenciometro y un adc que vaya 0-180 grados</p> <p>INFO IMPORTANTE</p> <p>El movimiento de un servo requiere alimentacion 5-6v y en el pin de signal, un pwm a 50 HZ con un pulso de 1-2ms que representa 0-180 grados</p>"},{"location":"Tarea_9/servo_adc/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n#include \"hardware/pwm.h\"\n\n#define SERVO_PIN 1    \n#define ADC_INPUT 0     \n#define N_muestras 16    \n\n#define TOP 1023         \n#define F_SERVO_HZ 50    \n\n#define SERVO_MIN 51      \n#define SERVO_MAX 102   \n\nint main() {\n    stdio_init_all();\n    adc_init();\n    adc_gpio_init(27);\n    adc_select_input(ADC_INPUT);\n\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN);\n    uint chan = pwm_gpio_to_channel(SERVO_PIN);\n\n    float f_clk = 125000000.0f;\n    float div = f_clk / (F_SERVO_HZ * (TOP + 1)); \n    pwm_set_wrap(slice, TOP);\n    pwm_set_clkdiv(slice, div);\n    pwm_set_enabled(slice, true);\n\n    uint16_t buffer[N_muestras];\n    uint32_t suma = 0;\n    uint8_t indice = 0; \n    uint8_t cuenta = 0;\n\n\n    while (true) {\n        uint16_t lectura = adc_read();\n\n        if (cuenta &lt; N_muestras) {\n            buffer[indice] = lectura;\n            suma += lectura;\n            cuenta++;\n            indice++;\n        } else {\n            suma -= buffer[indice];\n            buffer[indice] = lectura;\n            suma += lectura;\n            indice++;\n            if (indice &gt;= N_muestras) indice = 0;\n\n            uint16_t promedio = suma / N_muestras;\n            uint16_t pulso = SERVO_MIN + (promedio * (SERVO_MAX - SERVO_MIN)) / 4095;\n            pwm_set_chan_level(slice, chan, pulso);\n\n            uint16_t grados = (promedio * 180) / 4095;\n\n            printf(\"Grados: %u\u00b0\\n\", grados);\n\n            sleep_ms(200);\n        }\n    }\n}\n</code></pre>"},{"location":"Tarea_9/servo_adc/#esquema","title":"Esquema","text":""},{"location":"Tarea_9/servo_adc/#video","title":"Video","text":""}]}